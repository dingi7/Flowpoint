# ДОКУМЕНТАЦИЯ НА ПРОЕКТА CRM v2

## Съдържание

1. [Цели](#41-цели)
2. [Основни етапи в реализирането на проекта](#42-основни-етапи-в-реализирането-на-проекта)
3. [Ниво на сложност на проекта](#43-ниво-на-сложност-на-проекта)
4. [Логическо и функционално описание на решението](#44-логическо-и-функционално-описание-на-решението)
5. [Реализация](#45-реализация)
6. [Описание на приложението](#46-описание-на-приложението)
7. [Заключение](#47-заключение)

---

## 4.1. Цели

### Предназначение

CRM v2 е модерна система за управление на взаимоотношенията с клиенти (Customer Relationship Management), разработена с цел да предостави пълнофункционално решение за управление на бизнес операциите. Системата е предназначена за малки и средни бизнеси, които се нуждаят от:

- Управление на клиенти и техните данни
- Резервация и управление на срещи/часове
- Управление на услуги и продукти
- Управление на екип и роли
- Календарно планиране и наличност
- Публичен API за интеграция с външни системи
- Уиджет за онлайн резервации

### Кратък анализ на потребностите

Съвременните бизнеси се нуждаят от централизирана система, която да:

1. **Централизира данните за клиентите** – вместо разпръснати Excel таблици или ръчно водени записи
2. **Автоматизира процеса на резервации** – позволява на клиентите да резервират онлайн без човешка намеса
3. **Подобрява комуникацията** – автоматични напомняния за срещи, уведомления за промени
4. **Осигурява достъп от всяко място** – cloud базирано решение, достъпно от всяко устройство
5. **Интегрира се с други системи** – чрез REST API и webhooks за синхронизация на данни
6. **Поддържа multi-tenant архитектура** – позволява на множество организации да използват системата независимо

### Анализ на съществуващите решения

На пазара съществуват различни CRM решения, но повечето от тях имат следните недостатъци:

- **Високи разходи** – месечни абонаментни такси, които могат да бъдат непосилни за малки бизнеси
- **Сложност** – многофункционални системи, които са прекалено сложни за нуждите на малките предприятия
- **Липса на гъвкавост** – трудно се адаптират към специфичните нужди на различни индустрии
- **Липса на интеграции** – ограничени възможности за интеграция с други системи
- **Затворени системи** – липса на публичен API или ограничен достъп до данните

CRM v2 решава тези проблеми чрез:

- **Open-source подход** – кодът е достъпен и може да бъде адаптиран
- **Модулна архитектура** – лесно разширяване и персонализация
- **Публичен API** – пълна интеграция с външни системи
- **Съвременни технологии** – бърза и надеждна система
- **Multi-tenant дизайн** – ефективно използване на ресурси

---

## 4.2. Основни етапи в реализирането на проекта

### Етап 1: Планиране и проектиране (Design Phase)

**Дейности:**
- Анализ на изискванията и функционалностите
- Проектиране на архитектурата на системата
- Определяне на технологичния стек
- Проектиране на базата данни и структурата на данните
- Проектиране на API endpoints и webhooks

**Резултати:**
- Документация за архитектурата
- ER диаграми и схеми на базата данни
- API спецификация (OpenAPI)
- Техническа документация

### Етап 2: Разработка на backend (Backend Development)

**Дейности:**
- Настройка на Firebase проект и инфраструктура
- Имплементация на Cloud Functions
- Разработка на repository layer за достъп до данни
- Имплементация на бизнес логика и валидации
- Разработка на API endpoints с API key автентикация
- Имплементация на webhook система
- Интеграция с Clerk за автентикация
- Интеграция с Mailgun за имейл известия
- Интеграция с Google Cloud Secret Manager за управление на секрети

**Резултати:**
- Функционален backend с всички CRUD операции
- API с пълна документация
- Webhook система за реално време уведомления
- Система за управление на API ключове

### Етап 3: Разработка на frontend (Frontend Development)

**Дейности:**
- Настройка на React приложение с Vite
- Разработка на UI компоненти с Radix UI и Tailwind CSS
- Имплементация на routing и навигация
- Интеграция с Clerk за автентикация
- Разработка на страници за управление на:
  - Клиенти
  - Срещи/апойнтмънти
  - Услуги
  - Екип и роли
  - Организация и настройки
- Имплементация на календар за визуализация на срещи
- Разработка на dashboard с аналитика

**Резултати:**
- Пълнофункционално web приложение
- Responsive дизайн за мобилни устройства
- Интуитивен потребителски интерфейс

### Етап 4: Разработка на Widget SDK (Widget Development)

**Дейности:**
- Разработка на embeddable widget за резервации
- Имплементация на публични API endpoints за widget
- Разработка на booking flow с multiple steps
- Интеграция с availability система
- Тестване на widget в различни среди

**Резултати:**
- Готов за използване widget за резервации
- Документация за интеграция

### Етап 5: Тестване и оптимизация (Testing & Optimization)

**Дейности:**
- Unit тестове за критични компоненти
- Integration тестове за API endpoints
- Тестване на security rules
- Performance оптимизация
- Оптимизация на database queries и indexes
- Тестване на webhook доставка

**Резултати:**
- Стабилна и оптимизирана система
- Документация за тестване

### Етап 6: Деплой и поддръжка (Deployment & Maintenance)

**Дейности:**
- Настройка на CI/CD pipeline с GitHub Actions
- Конфигуриране на Firebase Hosting
- Деплой на Cloud Functions
- Настройка на monitoring и logging
- Документиране на deployment процеса
- Създаване на user documentation

**Резултати:**
- Production-ready система
- Автоматизиран deployment процес
- Monitoring и alerting система

### Роли на авторите

Проектът е разработен от екип с различни роли:

- **Backend Developer** – отговорен за Cloud Functions, API, database логика
- **Frontend Developer** – отговорен за React приложението и UI компонентите
- **DevOps Engineer** – отговорен за инфраструктурата, deployment и CI/CD
- **Product Owner** – отговорен за изискванията и функционалностите
- **QA Engineer** – отговорен за тестване и качество на кода

---

## 4.3. Ниво на сложност на проекта

### Обща оценка на сложността

Проектът се характеризира с **висока сложност** поради следните фактори:

1. **Multi-tenant архитектура** – необходимост от изолиране на данни между организации
2. **Различни типове автентикация** – Clerk за потребители, API keys за външни системи
3. **Сложна бизнес логика** – управление на наличност, конфликти в календара, автоматични напомняния
4. **Real-time функционалности** – webhooks, live updates на данни
5. **Интеграции с множество услуги** – Firebase, Clerk, Mailgun, Google Cloud Services
6. **Security изисквания** – защита на данни, API key management, webhook signatures

### Основни проблеми при реализация

#### Проблем 1: Multi-tenant изолация на данни

**Проблем:** Необходимост от гарантиране, че данните на една организация не са достъпни за друга организация.

**Решение:**
- Използване на Firestore security rules за изолация на данни на ниво база данни
- Структуриране на данните по организация: `/organizations/{orgId}/...`
- Валидация на organizationId във всички операции
- Repository pattern, който винаги изисква organizationId

#### Проблем 2: Управление на API ключове

**Проблем:** Безопасно съхранение и валидиране на API ключове без да се съхраняват в plain text.

**Решение:**
- Използване на Google Cloud Secret Manager за съхранение на API ключове
- Хеширане на API ключове с SHA-256 преди съхранение
- Създаване на mapping таблица между хешовете и organizationId
- Валидация чрез сравняване на хешовете вместо plain text ключове

#### Проблем 3: Управление на наличност и конфликти

**Проблем:** Предотвратяване на двойни резервации и проверка на наличност в реално време.

**Решение:**
- Комплексна валидация преди създаване на резервация:
  - Проверка за конфликти с други резервации
  - Проверка за time-off периоди
  - Проверка за работно време и почивни дни
  - Проверка за buffer time между резервации
- Използване на database transactions където е възможно
- Оптимизирани queries с правилни индекси

#### Проблем 4: Webhook доставка и сигурност

**Проблем:** Гарантиране на надеждна доставка на webhooks и предотвратяване на подправяне.

**Решение:**
- Използване на HMAC SHA-256 signatures за всеки webhook
- Retry механизъм за неуспешни доставки
- Валидация на callback URLs преди създаване на subscription
- Изпращане на secret при създаване на subscription за верификация

#### Проблем 5: Performance и мащабируемост

**Проблем:** Осигуряване на бързо време за отговор при голям брой данни.

**Решение:**
- Оптимизирани Firestore queries с composite indexes
- Кеширане на данни на frontend с TanStack Query
- Lazy loading на компоненти
- Code splitting за по-малки bundle sizes
- Използване на Cloud Functions v2 за по-добра performance

#### Проблем 6: Синхронизация между системи

**Проблем:** Синхронизация на данни между Clerk (автентикация) и Firestore (данни).

**Решение:**
- Webhook handlers за Clerk събития (user created, user deleted)
- Автоматично създаване на user записи в Firestore при регистрация
- Автоматично изтриване на свързани данни при изтриване на потребител
- Използване на Cloud Pub/Sub за асинхронна обработка

---

## 4.4. Логическо и функционално описание на решението

### Архитектура на системата

Системата следва **Clean Architecture** принципи с ясно разделение на слоеве:

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                        │
│  (React Frontend, Widget SDK, External API Consumers)       │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                   Application Layer                          │
│  (Cloud Functions, API Endpoints, Business Logic)          │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                    Domain Layer                              │
│  (Entities, Ports/Interfaces, Business Rules)              │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                Infrastructure Layer                          │
│  (Firestore, Clerk, Mailgun, Secret Manager, Pub/Sub)      │
└─────────────────────────────────────────────────────────────┘
```

### Модули на системата

#### 1. Frontend модул (`front-end/`)

**Предназначение:** Потребителски интерфейс за управление на CRM системата.

**Структура:**
```
front-end/
├── src/
│   ├── components/          # UI компоненти
│   │   ├── auth/            # Компоненти за автентикация
│   │   ├── appointment/     # Компоненти за срещи
│   │   ├── customer/        # Компоненти за клиенти
│   │   ├── service/         # Компоненти за услуги
│   │   ├── member/          # Компоненти за екип
│   │   ├── layout/          # Layout компоненти
│   │   └── ui/              # Базови UI компоненти
│   ├── pages/               # Страници на приложението
│   │   ├── dashboard/      # Начална страница
│   │   ├── appointments/    # Страница за срещи
│   │   ├── customers/      # Страница за клиенти
│   │   ├── services/        # Страница за услуги
│   │   ├── team/            # Страница за екип
│   │   └── organization/    # Страница за организация
│   ├── core/                # Domain layer
│   │   ├── entities/        # Бизнес ентитети
│   │   └── ports/           # Интерфейси
│   ├── repositories/        # Data access layer
│   ├── hooks/               # React hooks
│   ├── services/            # Външни услуги
│   └── utils/               # Помощни функции
```

**Функции:**
- Управление на клиенти (създаване, редактиране, изтриване, търсене)
- Управление на срещи (създаване, редактиране, отмяна, статуси)
- Управление на услуги (CRUD операции)
- Управление на екип и роли
- Календарна визуализация на срещи
- Dashboard с аналитика
- Настройки на организация

**Взаимодействия:**
- Комуникира с backend чрез Firebase SDK
- Използва Clerk за автентикация
- Използва TanStack Query за кеширане и синхронизация на данни

#### 2. Backend модул (`functions/`)

**Предназначение:** Бизнес логика, API endpoints, и интеграции.

**Структура:**
```
functions/
├── src/
│   ├── app/                 # Application layer
│   │   ├── appointment/     # Логика за срещи
│   │   ├── availability/    # Логика за наличност
│   │   ├── clerk/           # Интеграция с Clerk
│   │   └── organization/    # Логика за организации
│   ├── functions/           # Cloud Functions дефиниции
│   │   ├── api/             # API endpoints
│   │   ├── widget/          # Widget endpoints
│   │   ├── webhooks/        # Webhook handlers
│   │   └── appointment/     # Appointment functions
│   ├── core/                # Domain layer
│   │   ├── entities/        # Бизнес ентитети
│   │   ├── ports/           # Интерфейси
│   │   └── dtos/            # Data Transfer Objects
│   ├── repositories/        # Data access implementations
│   ├── services/            # Business services
│   └── utils/               # Помощни функции
```

**Функции:**
- CRUD операции за всички ентитети
- API endpoints с API key автентикация
- Widget endpoints за публичен достъп
- Webhook система за уведомления
- Интеграция с Clerk за автентикация
- Имейл известия чрез Mailgun
- Управление на наличност и конфликти
- Автоматични напомняния за срещи

**Взаимодействия:**
- Използва Firestore за данни
- Интегрира се с Clerk за автентикация
- Използва Mailgun за имейли
- Използва Google Cloud Secret Manager за секрети
- Използва Cloud Pub/Sub за асинхронни задачи

#### 3. Widget SDK модул (`widget-sdk/`)

**Предназначение:** Embeddable widget за онлайн резервации.

**Функции:**
- Показване на налични услуги
- Избор на дата и час
- Избор на служител (ако приложимо)
- Форма за данни на клиента
- Потвърждение на резервация

**Взаимодействия:**
- Комunикира с публични widget API endpoints
- Може да бъде embeddable в всякакъв уебсайт

#### 4. First-class модул (`first-class/`)

**Предназначение:** Публичен уебсайт (marketing site) с интегриран booking widget.

**Функции:**
- Публичен уебсайт за организация
- Интегриран booking flow
- Показване на услуги и информация

### Основни ентитети и техните функции

#### 1. Organization (Организация)

**Описание:** Представлява бизнес организация, която използва системата.

**Поля:**
- `id` – уникален идентификатор
- `name` – име на организацията
- `image` – лого на организацията
- `industry` – индустрия
- `currency` – валута
- `settings` – настройки (timezone, работно време, политики)
- `apiKeys` – списък с API ключове

**Функции:**
- Централен ентитет за multi-tenant изолация
- Съдържа настройки за цялата организация
- Управлява API ключове за външен достъп

#### 2. User (Потребител)

**Описание:** Потребител в системата (управляван от Clerk).

**Поля:**
- `uid` – уникален идентификатор от Clerk
- `email` – имейл адрес
- `displayName` – име за показване
- `photoURL` – URL на снимка

**Функции:**
- Автентикация и авторизация
- Свързване с Member записи

#### 3. Member (Член на екипа)

**Описание:** Член на екипа на организацията.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `userId` – ID на потребителя (от Clerk)
- `name` – име
- `image` – снимка
- `description` – описание
- `roleIds` – списък с роли

**Функции:**
- Представлява служител в организацията
- Свързва User с Organization
- Има свързани роли за permissions

#### 4. Customer (Клиент)

**Описание:** Клиент на организацията.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `email` – имейл адрес
- `customFields` – персонализирани полета (name, phone, address, notes, etc.)

**Функции:**
- Съхранява данни за клиентите
- Поддържа персонализирани полета за различни индустрии
- Свързан с appointments

#### 5. Service (Услуга)

**Описание:** Услуга, предлагана от организацията.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `ownerType` – тип собственик ("member" или "organization")
- `ownerId` – ID на собственика
- `name` – име на услугата
- `description` – описание
- `price` – цена
- `duration` – продължителност в минути
- `image` – изображение
- `order` – ред за показване

**Функции:**
- Дефинира услуги, които могат да бъдат резервирани
- Може да принадлежи на конкретен член или на цялата организация
- Използва се при създаване на appointments

#### 6. Appointment (Среща/Резервация)

**Описание:** Резервация за среща.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `assigneeType` – тип назначен ("member" или "organization")
- `assigneeId` – ID на назначения
- `customerId` – ID на клиента
- `serviceId` – ID на услугата
- `calendarId` – ID на календара
- `title` – заглавие
- `description` – описание
- `startTime` – начален час (ISO 8601)
- `duration` – продължителност в минути
- `fee` – такса
- `status` – статус ("pending", "completed", "cancelled")

**Функции:**
- Представлява резервация за среща
- Валидира се за конфликти и наличност
- Може да бъде създадена от widget или от admin интерфейса

#### 7. Calendar (Календар)

**Описание:** Календар за член на екипа или организация.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `ownerType` – тип собственик
- `ownerId` – ID на собственика
- `name` – име на календара
- `timezone` – часова зона
- `workingDays` – работни дни
- `workingHours` – работно време

**Функции:**
- Дефинира работно време и наличност
- Използва се за валидация на appointments
- Всеки member или organization може да има календар

#### 8. Time Off (Почивка)

**Описание:** Период на почивка за член на екипа.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `memberId` – ID на членa
- `startTime` – начален час
- `endTime` – краен час
- `reason` – причина

**Функции:**
- Маркира периоди, когато член на екипа не е наличен
- Използва се при валидация на appointments

#### 9. Role (Роля)

**Описание:** Роля за контрол на достъпа.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `name` – име на ролята
- `permissions` – списък с permissions

**Функции:**
- Дефинира permissions за членове на екипа
- Използва се за Role-Based Access Control (RBAC)

#### 10. Invite (Покана)

**Описание:** Покана за присъединяване към организация.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `inviterId` – ID на поканилия
- `inviteeEmail` – имейл на поканения
- `roleIds` – роли, които ще получи
- `status` – статус ("pending", "accepted", "expired")
- `validFor` – валидност в дни

**Функции:**
- Управлява покани за нови членове
- Изпраща имейл с линк за приемане

#### 11. WebhookSubscription (Webhook Абонамент)

**Описание:** Абонамент за webhook уведомления.

**Поля:**
- `id` – уникален идентификатор
- `organizationId` – ID на организацията
- `eventTypes` – типове събития
- `callbackUrl` – URL за изпращане на webhooks
- `secret` – secret за верификация
- `status` – статус ("active", "inactive")

**Функции:**
- Управлява webhook subscriptions
- Изпраща уведомления при събития

### Взаимодействия между модулите

#### Frontend ↔ Backend

```
Frontend (React)
    │
    ├─► Firebase SDK ──► Firestore (Read/Write данни)
    │
    ├─► Clerk SDK ──► Clerk (Автентикация)
    │
    └─► Firebase Functions ──► Cloud Functions (Callable functions)
```

#### Backend ↔ External Services

```
Cloud Functions
    │
    ├─► Firestore ──► Database операции
    │
    ├─► Clerk Backend SDK ──► User management
    │
    ├─► Mailgun API ──► Имейл известия
    │
    ├─► Secret Manager ──► API key storage
    │
    └─► Pub/Sub ──► Асинхронни задачи
```

#### Widget ↔ Backend

```
Widget SDK
    │
    └─► Public API Endpoints ──► Widget-specific endpoints
        (без автентикация, само organizationId)
```

#### External Systems ↔ Backend

```
External Systems
    │
    └─► API Endpoints ──► API key автентикация
        └─► CRUD операции
        └─► Webhook subscriptions
```

### Поток на данни при основни операции

#### Поток при резервация (Booking Flow)

```
1. Widget/UI изпраща заявка за резервация
   │
2. Backend валидира:
   - Услугата съществува
   - Клиентът съществува (или се създава)
   - Няма конфликти в календара
   - Няма time-off периоди
   - Работно време и почивни дни
   │
3. Създава се Appointment запис
   │
4. Изпраща се имейл потвърждение
   │
5. Създава се задача за напомняне (Cloud Tasks)
   │
6. Изпраща се webhook (ако има subscription)
   │
7. Връща се потвърждение на клиента
```

#### Поток при API заявка

```
1. External система изпраща заявка с API key
   │
2. Backend валидира API key:
   - Извлича hash от API key
   - Търси в hash mapping таблица
   - Проверява в Secret Manager
   - Валидира organizationId
   │
3. Изпълнява се операцията
   │
4. Връща се резултат
```

#### Поток при webhook събитие

```
1. Събитие в системата (напр. customer.created)
   │
2. Backend намира активни webhook subscriptions
   │
3. За всеки subscription:
   - Генерира payload
   - Създава HMAC signature
   - Изпраща POST заявка към callbackUrl
   │
4. Ако неуспешно, retry с exponential backoff
```

---

## 4.5. Реализация

### Технологичен стек

#### Frontend технологии

**React 19.1.0**
- Избран поради голямата общност, богатството на библиотеки и компонентния подход
- Позволява бърза разработка на интерактивни UI компоненти
- Добра поддръжка за TypeScript

**Vite 6.3.5**
- Модерен build tool с бързо време за стартиране
- HMR (Hot Module Replacement) за бърз development
- Оптимизирани production builds

**TypeScript 5.8.3**
- Статична типизация за по-малко грешки
- По-добра поддръжка от IDE
- Документиране на типове в кода

**Tailwind CSS 4.1.10**
- Utility-first CSS framework
- Бързо стилизиране без custom CSS
- Responsive design out of the box

**Radix UI**
- Headless UI компоненти за достъпност
- Компоненти като Dialog, Dropdown, Select и др.
- Пълна контрол над стилизирането

**TanStack Query (React Query) 5.81.2**
- Управление на server state
- Автоматично кеширане и синхронизация
- Оптимистични updates

**React Hook Form 7.58.1**
- Ефективно управление на форми
- Интеграция с Zod за валидация
- Минимални re-renders

**Zod 3.25.67**
- Schema validation библиотека
- Type-safe валидация
- Използва се и на frontend и на backend

**React Router 7.6.2**
- Client-side routing
- Protected routes с автентикация
- Code splitting по routes

**Clerk 5.32.1**
- Complete authentication solution
- Pre-built UI компоненти
- User management и session handling

#### Backend технологии

**Node.js 22**
- JavaScript runtime за server-side код
- Голяма екосистема от библиотеки
- Еднаква езикова база с frontend

**TypeScript 5.8.3**
- Същите предимства като на frontend
- Type safety в целия stack

**Firebase Cloud Functions 6.6.0**
- Serverless functions platform
- Автоматично мащабиране
- Интеграция с други Firebase услуги
- Pay-as-you-go модел

**Firebase Firestore**
- NoSQL database
- Real-time updates
- Автоматично мащабиране
- Security rules за защита на данни

**Firebase Admin SDK 13.4.0**
- Server-side Firebase операции
- Управление на потребители
- Database операции с admin права

**Clerk Backend SDK 2.4.0**
- Server-side автентикация
- User management
- Webhook handling

**Google Cloud Secret Manager 6.1.1**
- Безопасно съхранение на секрети
- Versioning на секрети
- Access control

**Google Cloud Pub/Sub 5.1.0**
- Асинхронна комуникация
- Event-driven архитектура
- Reliable message delivery

**Google Cloud Tasks 5.3.0**
- Scheduled tasks
- Retry механизъм
- Task queues

**Mailgun.js 12.1.1**
- Имейл изпращане
- Transactional emails
- Email templates

**Svix 1.68.0**
- Webhook management
- Signature verification
- Delivery tracking

#### Инфраструктура

**Firebase Hosting**
- Static site hosting за frontend
- CDN за бързо зареждане
- Автоматичен SSL

**Firebase Emulators**
- Local development environment
- Тестване преди deployment

**GitHub Actions**
- CI/CD pipeline
- Автоматичен deployment
- Automated testing

### Архитектурни решения

#### Clean Architecture

Избрана е Clean Architecture за следните причини:

1. **Разделение на отговорности** – всеки слой има ясна роля
2. **Тестваемост** – лесно тестване на бизнес логика независимо от инфраструктурата
3. **Гъвкавост** – лесно подменяне на компоненти (напр. Firestore с друга база данни)
4. **Поддръжка** – по-лесно разбиране и поддръжка на кода

#### Repository Pattern

Използван е Repository Pattern за:

1. **Абстракция на data access** – бизнес логиката не зависи от конкретната база данни
2. **Тестване** – лесно създаване на mock repositories
3. **Еднозначност** – един repository за един ентитет
4. **Организация** – ясна структура на кода

#### Dependency Injection

Използвана е Dependency Injection за:

1. **Loose coupling** – компонентите не са тясно свързани
2. **Тестване** – лесно подменяне на зависимости
3. **Гъвкавост** – различни имплементации за различни среди

#### API Key Authentication

Избрана е API key автентикация за:

1. **Простота** – лесно използване от външни системи
2. **Безопасност** – API ключовете се съхраняват безопасно в Secret Manager
3. **Контрол** – лесно revoke на ключове
4. **Audit** – проследяване на използването

#### Webhook System

Имплементирана е webhook система за:

1. **Real-time уведомления** – външните системи получават веднага информация за събития
2. **Decoupling** – системата не зависи от външните системи
3. **Scalability** – може да има много subscribers
4. **Reliability** – retry механизъм за гарантирана доставка

### Алгоритми и структури от данни

#### Алгоритъм за валидация на наличност

```typescript
function validateAvailability(startTime, duration, assigneeId) {
  // 1. Проверка за работно време
  if (!isWithinWorkingHours(startTime, duration)) {
    return { valid: false, reason: "outside_working_hours" };
  }
  
  // 2. Проверка за почивни дни
  if (isHoliday(startTime)) {
    return { valid: false, reason: "holiday" };
  }
  
  // 3. Проверка за time-off периоди
  if (hasTimeOffConflict(startTime, duration, assigneeId)) {
    return { valid: false, reason: "time_off" };
  }
  
  // 4. Проверка за конфликти с други appointments
  if (hasAppointmentConflict(startTime, duration, assigneeId)) {
    return { valid: false, reason: "conflict" };
  }
  
  // 5. Проверка за buffer time
  if (hasBufferTimeConflict(startTime, duration, assigneeId)) {
    return { valid: false, reason: "buffer_time" };
  }
  
  return { valid: true };
}
```

#### Структура на данни за API key hash mapping

```typescript
// Hash mapping таблица в Firestore
{
  id: "sha256_hash_of_api_key",
  secretId: "secret_id_in_secret_manager",
  organizationId: "org_123"
}

// Organization document
{
  id: "org_123",
  apiKeys: [
    {
      name: "Production API Key",
      secretId: "secret_id_in_secret_manager",
      createdAt: Date,
      status: "active" | "revoked",
      lastFour: "abcd" // последни 4 символа за показване
    }
  ]
}
```

#### Алгоритъм за webhook signature

```typescript
function generateWebhookSignature(payload, secret) {
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(JSON.stringify(payload));
  return hmac.digest('hex');
}

function verifyWebhookSignature(payload, signature, secret) {
  const computedSignature = generateWebhookSignature(payload, secret);
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(computedSignature)
  );
}
```

### Литература и ресурси

#### Официална документация

- **Firebase Documentation** – https://firebase.google.com/docs
- **React Documentation** – https://react.dev
- **TypeScript Handbook** – https://www.typescriptlang.org/docs/
- **Clerk Documentation** – https://clerk.com/docs
- **TanStack Query Documentation** – https://tanstack.com/query/latest

#### Архитектурни паттерни

- **Clean Architecture** – книга от Robert C. Martin
- **Domain-Driven Design** – книга от Eric Evans
- **Repository Pattern** – Martin Fowler's Patterns of Enterprise Application Architecture

#### Best Practices

- **Firebase Security Rules Best Practices**
- **React Best Practices и Patterns**
- **TypeScript Best Practices**
- **API Design Guidelines**

### Програмни приложения и инструменти

#### Development Tools

- **VS Code** – код редактор с TypeScript поддръжка
- **Firebase CLI** – за deployment и управление
- **Git** – version control
- **npm/yarn** – package management

#### Testing Tools

- **Jest** – unit testing framework
- **Firebase Emulators** – local testing environment

#### CI/CD Tools

- **GitHub Actions** – автоматизация на deployment
- **Firebase Hosting** – hosting на frontend
- **Cloud Functions** – hosting на backend

#### Monitoring Tools

- **Firebase Console** – monitoring на функции и база данни
- **Google Cloud Console** – monitoring на инфраструктурата
- **Clerk Dashboard** – monitoring на потребители

---

## 4.6. Описание на приложението

### Инсталация и настройка

#### Предварителни изисквания

1. **Node.js 22+** – инсталиран на системата
2. **npm или yarn** – package manager
3. **Firebase CLI** – инсталиран глобално
4. **Git** – за клониране на repository
5. **Firebase проект** – създаден в Firebase Console
6. **Clerk акаунт** – за автентикация

#### Стъпки за инсталация

**1. Клониране на repository**

```bash
git clone <repository-url>
cd CRM-v2
```

**2. Инсталация на frontend зависимости**

```bash
cd front-end
npm install
```

**3. Инсталация на backend зависимости**

```bash
cd ../functions
npm install
```

**4. Конфигуриране на environment variables**

**Frontend (.env.development):**
```env
VITE_CLERK_PUBLISHABLE_KEY=pk_test_...
VITE_FIREBASE_API_KEY=...
VITE_FIREBASE_AUTH_DOMAIN=...
VITE_FIREBASE_PROJECT_ID=...
VITE_FIREBASE_STORAGE_BUCKET=...
VITE_FIREBASE_MESSAGING_SENDER_ID=...
VITE_FIREBASE_APP_ID=...
```

**Backend (Firebase Functions secrets):**
```bash
firebase functions:secrets:set MAILGUN_API_KEY
firebase functions:secrets:set MAILGUN_DOMAIN
firebase functions:secrets:set MAILGUN_URL
firebase functions:secrets:set CLERK_SECRET_KEY
```

**5. Настройка на Firebase проект**

```bash
firebase login
firebase use --add  # Избор на проект
```

**6. Деплой на Firestore rules и indexes**

```bash
firebase deploy --only firestore:rules
firebase deploy --only firestore:indexes
```

### Стартиране на приложението

#### Development режим

**Frontend:**
```bash
cd front-end
npm run dev
```
Приложението ще стартира на `http://localhost:5173`

**Backend (с emulators):**
```bash
cd functions
npm run emulators
```
Това стартира всички Firebase emulators (Functions, Firestore, Auth)

**Backend (само functions):**
```bash
cd functions
npm run serve
```

#### Production build

**Frontend:**
```bash
cd front-end
npm run build
```
Генерира статични файлове в `dist/` директорията

**Backend:**
```bash
cd functions
npm run build
```
Компилира TypeScript към JavaScript в `lib/` директорията

### Deployment

#### Frontend deployment

```bash
cd front-end
npm run build
firebase deploy --only hosting
```

#### Backend deployment

```bash
cd functions
npm run build
firebase deploy --only functions
```

#### Пълно deployment

```bash
firebase deploy
```

### Използване на приложението

#### За потребители (End Users)

1. **Регистрация и вход**
   - Посещение на `/sign-up` за регистрация
   - Или `/sign-in` за вход
   - Използва се Clerk за автентикация

2. **Създаване на организация**
   - При първо влизане се създава нова организация
   - Попълване на основна информация

3. **Управление на клиенти**
   - Навигация към `/customers`
   - Създаване на нов клиент с "New Customer" бутон
   - Редактиране и изтриване на клиенти

4. **Управление на услуги**
   - Навигация към `/services`
   - Създаване на услуги с цена и продължителност
   - Присвояване на услуга към член на екипа или организация

5. **Управление на срещи**
   - Навигация към `/appointments`
   - Създаване на нова среща с избор на клиент, услуга, дата и час
   - Промяна на статус (pending → completed → cancelled)
   - Календарна визуализация на `/calendar`

6. **Управление на екип**
   - Навигация към `/team`
   - Покана на нови членове чрез имейл
   - Присвояване на роли
   - Премахване на членове

7. **Настройки на организация**
   - Навигация към `/organization`
   - Конфигуриране на работно време
   - Управление на API ключове
   - Настройка на webhook subscriptions

#### За разработчици (Developers)

**Използване на API:**

1. **Създаване на API ключ**
   - В настройките на организацията
   - Генериране на нов API ключ
   - Запазване на ключа безопасно (показва се само веднъж)

2. **Използване на API endpoints**
   ```bash
   curl -X GET "https://[region]-[project-id].cloudfunctions.net/apiListServices" \
     -H "Authorization: Bearer YOUR_API_KEY"
   ```

3. **Webhook subscriptions**
   - Създаване на webhook subscription чрез `createWebhookSubscription` функция
   - Получаване на secret при създаване
   - Верификация на signatures при получаване на webhooks

**Интеграция на Widget:**

1. **Включване на widget script**
   ```html
   <script src="https://[widget-url]/booking.js"></script>
   ```

2. **Инициализация на widget**
   ```javascript
   <div id="booking-widget"></div>
   <script>
     BookingWidget.init({
       organizationId: 'your-org-id',
       containerId: 'booking-widget'
     });
   </script>
   ```

### Поддръжка и maintenance

#### Регулярни задачи

1. **Мониторинг на логове**
   - Проверка на Firebase Functions logs
   - Проверка на error rates
   - Мониторинг на performance метрики

2. **Backup на данни**
   - Firestore автоматично прави backups
   - Ръчни exports при необходимост:
     ```bash
     gcloud firestore export gs://[bucket-name]
     ```

3. **Обновяване на зависимости**
   ```bash
     npm outdated
     npm update
   ```

4. **Security updates**
   - Регулярно обновяване на зависимости
   - Проверка на security advisories
   - Ротация на API ключове

#### Troubleshooting

**Проблем: Cloud Functions не стартират**

Решение:
- Проверка на logs: `firebase functions:log`
- Проверка на quotas и limits
- Проверка на environment variables и secrets

**Проблем: Firestore queries са бавни**

Решение:
- Проверка на indexes: `firestore.indexes.json`
- Оптимизация на queries
- Използване на composite indexes където е необходимо

**Проблем: Webhooks не се доставят**

Решение:
- Проверка на callback URL (трябва да е HTTPS)
- Проверка на webhook logs
- Проверка на retry механизма

**Проблем: API key валидация не работи**

Решение:
- Проверка на Secret Manager permissions
- Проверка на API key hash mapping
- Проверка на organizationId в заявката

#### Performance оптимизация

1. **Database indexes**
   - Регулярна проверка на query patterns
   - Добавяне на composite indexes където е необходимо

2. **Caching**
   - Използване на TanStack Query за кеширане на frontend
   - Кеширане на често използвани данни

3. **Code splitting**
   - Lazy loading на компоненти
   - Dynamic imports за по-големи модули

4. **Bundle optimization**
   - Анализ на bundle size
   - Премахване на неизползвани зависимости

---

## 4.7. Заключение

### Основен резултат

CRM v2 е успешно реализирана система за управление на взаимоотношенията с клиенти, която предоставя:

1. **Пълнофункционално решение** за управление на бизнес операциите
2. **Модерна архитектура** с ясно разделение на слоеве и модули
3. **Scalable инфраструктура** базирана на Firebase и Google Cloud
4. **Публичен API** за интеграция с външни системи
5. **Widget за онлайн резервации** за директна интеграция в уебсайтове
6. **Webhook система** за real-time уведомления
7. **Multi-tenant поддръжка** за множество независими организации

Системата успешно решава проблемите на малките и средните предприятия за централизирано управление на клиенти, срещи и услуги, като същевременно предоставя гъвкавост и възможности за разширение.

### Приложения до момента

Системата е готова за използване в production среда и може да бъде приложена в различни индустрии:

1. **Сервизни бизнеси** – салони за красота, барбершопи, спа центрове
2. **Консултантски услуги** – юридически, финансови, бизнес консултанти
3. **Медицински практики** – частни клиники, терапия, консултации
4. **Образователни услуги** – частни уроци, курсове, обучения
5. **Технически услуги** – IT поддръжка, ремонти, инсталации

### Възможности за развитие и усъвършенстване

#### Краткосрочни подобрения (1-3 месеца)

1. **Mobile приложение**
   - React Native приложение за iOS и Android
   - Push notifications за срещи
   - Offline mode за основни операции

2. **Разширена аналитика**
   - Dashboard с графики и статистики
   - Отчети за приходи и приходи по период
   - Анализ на популярни услуги и клиенти

3. **SMS уведомления**
   - Интеграция с SMS provider (Twilio, etc.)
   - SMS напомняния за срещи
   - SMS потвърждения

4. **Плащания**
   - Интеграция с payment gateways (Stripe, PayPal)
   - Онлайн плащания при резервация
   - Управление на транзакции

5. **Multi-language поддръжка**
   - Интернационализация (i18n)
   - Поддръжка на множество езици
   - Локализация на дати и валути

#### Средносрочни подобрения (3-6 месеца)

1. **Advanced scheduling**
   - Recurring appointments
   - Group bookings
   - Waitlist функционалност

2. **Customer portal**
   - Потребителски портал за клиентите
   - История на срещи
   - Възможност за отмяна и пренасрочване

3. **Inventory management**
   - Управление на продукти и наличност
   - Свързване на продукти с услуги
   - Автоматично намаляване на наличност

4. **Marketing tools**
   - Email marketing интеграция
   - Промоции и отстъпки
   - Loyalty програми

5. **Advanced reporting**
   - Custom отчети
   - Export в различни формати (PDF, Excel, CSV)
   - Scheduled отчети по имейл

#### Дългосрочни подобрения (6+ месеца)

1. **AI и Machine Learning**
   - Predictive analytics за популярни часове
   - Автоматично препоръчване на услуги
   - Chatbot за customer support

2. **Advanced integrations**
   - Интеграция с калкулатори (Google Calendar, Outlook)
   - Интеграция с accounting софтуер (QuickBooks, Xero)
   - Интеграция с CRM системи (Salesforce, HubSpot)

3. **White-label решение**
   - Възможност за white-label deployment
   - Custom branding за всяка организация
   - Multi-brand поддръжка

4. **Enterprise features**
   - Advanced RBAC с custom permissions
   - Audit logs за всички операции
   - Data retention policies
   - Compliance features (GDPR, etc.)

5. **Performance оптимизации**
   - GraphQL API за по-ефективни заявки
   - Real-time synchronization с WebSockets
   - Advanced caching стратегии

### Технически подобрения

1. **Testing coverage**
   - Увеличаване на unit test coverage
   - Integration tests за критични flows
   - E2E tests с Playwright или Cypress

2. **Documentation**
   - API documentation с Swagger/OpenAPI
   - Developer guides
   - Video tutorials

3. **Monitoring и observability**
   - Интеграция с monitoring tools (Datadog, New Relic)
   - Distributed tracing
   - Performance monitoring

4. **Security enhancements**
   - Rate limiting на API endpoints
   - Advanced threat detection
   - Security audits и penetration testing

### Заключителни думи

CRM v2 представлява модерно и мащабируемо решение за управление на взаимоотношенията с клиенти, което успешно комбинира лекота на използване с мощни функционалности. Благодарение на модулната архитектура и използването на съвременни технологии, системата е готова за бъдещо разширение и адаптация към различни бизнес нужди.

Проектът демонстрира приложението на best practices в софтуерното инженерство, включително Clean Architecture, Domain-Driven Design, и TypeScript за type safety. Системата е проектирана да бъде поддържана, разширяема и надеждна, което я прави подходяща както за малки бизнеси, така и за по-големи организации с по-сложни изисквания.

---

**Дата на създаване:** Декември 2025  
**Версия:** 1.0  
**Статус:** Production Ready

